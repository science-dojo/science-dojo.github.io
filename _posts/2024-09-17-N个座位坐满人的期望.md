---
title: N个座位坐满人的期望
tags:
  - interview
  - dp
layout: single
toc: true
toc_sticky: true
toc_label: "目录"
---

公交车上有一排 n 个座位，这一排的 n 个座位有个规定：乘客选中落座的前后位置，不允许坐人。乘客依次上车，随机选座，求这个n个座位坐满人的期望。


# 示例分析

n=1 时，共有1种坐满人的坐法，坐满时的总人数为1，期望=$\frac{1}{1}=1$

n=2 时，共有2种坐满人的坐法，坐满时的总人数为2，期望=$\frac{2}{2}=1$

n=3 时，共有3中坐满人的坐法，坐满时的总人数为5，期望=$\frac{5}{3} \approx 1.67$
> - 第一种坐法: 第一个乘客选择中间位置坐，后来乘客按规则，无法选中第一和第三个座位，该坐法共有1人落座。
> - 第二种坐法：第一个乘客选择第一个位置，第二个乘客则只能选择最后一个位置，该坐法共有2人落座。
> - 第三种坐法：第一个乘客选择组后一个位置，第二个乘客则只能选择第一个位置，该坐法共有2人落座。

从示例易得，期望的计算公式, $h_i(n)$分别为 n 个座位时，第 i 个坐法可以落座的人数, N为坐法的数量

$$
  E(n) = \frac{\sum_{i=1}^{N}h_i(n)}{N}
$$

因此，问题的关键是求出座位数量为 n 时的所有坐法数量，以及每种坐法对应的落座人数。

# 子问题

假如已经知道 n 个座位时的所有坐法，出于临时需要，公交车上在最后临时增加了一个座位（第n+1个座位），该座位能否落座，取决于第n个座位是否有人落座。
因此，第n个位置（最后一个位置）是否有人落座，需要成为标记子问题的一个变量。

令：$f_1(n)$ 表示 **n个座位时，最后一个座位坐人时的方法数**， $f_2(n)$表示**n个座位时，最后一个座位不坐人时的方法数**
$h_1(n)$表示 n个座位时，最后一个座位坐人时，可落座的座位数量，$h_2(n)$表示n个座位时，最后一个位置不坐人时，可落座的座位数量。

n=1时：$h_1(1)=1, h_2(1)=0, f_1(1)=1, f_2(1)=0$
n=2时：$h_1(2)=1, h_2(2)=1, f_1(2)=1, f_2(2)=1$

| | n_1 | n_2 |
|:--:| :--: | :--: |
|i=1 | [1] | [] |
|i=2 | [] | [1] |


n_1, n_2 表示第一、第二个座位，第一列标记i=1, i=2 表示第一、第二个坐法，[]表示座位空置，[1]表示该座位被第一个人入座，
例如，当i=1时，在该坐法下，第一个座位可以坐人，但因为只有该位置可以坐人，所以该只有一种坐法。

n=3时，$h_1(3) = h_2(2) + 1=2, h_2(3) = h_1(2)=1,, f_1(3) = f_2(2) \times h_1(3) = 2, f_2(3)=f_1(2) =1$
| | n_1 | n_2 | n_3 |
|:--:| :--: | :--: | :--: |
|i=1 | [] | [1] | [] |
|i=2 | [1] | [] | [2] |
|i=3 | [2] | [] | [1] |

n=3时，当最后一个位置可以落座时，可落座的状态，必须从n=2时，最后一个位置不可落座时的状态转移过来，否则将不满足约束条件。
此时，可落座的位置数量为 $h_2(2) + 1 = 2$。由于第三个位置可以落座，此时第一个用户可以选择第一个座位和第三个座位入座，有两种选择，第二个用户只有一种选择，可落座的方法数量为 2。
从座位的角度看，新增座位也有两种选择：第一个用户入座，第二个用户入座；**可落座的座位数量也是新增座位的选择数量**，所以$f_1(3)=f_2(2) \times h_1(3) = 2$。

同理，n=3时，当最后一个位置不可落座时，可落座数量，就是n=2时的最后一个位置可坐人时的可落座数量, 由于没有新的位置可以落座 $f_2(3) = f_1(2)$


| | n_1 | n_2 | n_3 | n_4 |
|:--:| :--: | :--: | :--: | :--: |
|i=1 | [] | [1] | [] | [2] |
|i=2 | [1] | [] | [2] | [] |
|i=3 | [2] | [] | [1] | [] |
|i=4 | [] | [2] | [] | [1] |


| | n_1 | n_2 | n_3 | n_4 | n_5|
|:--:| :--: | :--: | :--: | :--: | :--: |
|i=1 | [] | [1] | [] | [2] | [] |
|i=2 | [1] | [] | [2] | [] | [3] |
|i=3 | [2] | [] | [1] | [] | [3] |
|i=4 | [] | [2] | [] | [1] | [] |
|i=5 | [2] | [] | [3] | [] | [1] |
|i=6 | [1] | [] | [3] | [] | [2] |
|i=7 | [3] | [] | [1] | [] | [2] |
|i=8 | [1] | [] | [2] | [] | [1] |

状态转移公式：

$$

h_1(n) = h_2(n-1) + 1 \\
h_2(n) = h_1(n-1) \\
f_1(n) = f_2(n-1) * h_1(n) \\
f_2(n) = f_1(n-1) \\

E(n) = \frac{f_1(n) \times h_1(n) + f_2(n) \times h_2(n)}{f_1(n) + f_2(n)}

$$

# 代码

```c++
double solve(int n) {
    vector<int> h1(n+1), h2(n+1); // 最后一个位置坐人/不坐人的可坐座位数量
    vector<int> f1(n+1), f2(n+1); // 最后一个位置坐人/不坐人的方法数
    if(n<1) return -1; // invalid
    h1[1] = 1; h2[1] = 0;
    f1[1] = 1; f2[1] = 0;
    
    h1[2] = 1; h2[2] = 1;
    f1[2] = 1; f2[2] = 1;
    if (n==1 || n==2) {
        return (h1[n] * f1[n] + h2[n]*f2[n]);
    }
    for(int i=3; i<=n; ++i) {
        h1[i] = h2[i-1] + 1; h2[i] = h1[i-1];
        f1[i] = f2[i-1] * h1[i]; f2[i] = f1[i-1];
    }
    return (f1[n] * h1[n] + f2[n] * h2[n]) * 1. / (f1[n]+f2[n]);
}
```
```
```
